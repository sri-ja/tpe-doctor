{"ast":null,"code":"var _jsxFileName = \"/home/shambhavi/Documents/4-2/tpe/app/tpe-doctor/doctor/frontend/src/context/ReviewSessionContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from \"react\";\nimport { API_BASE_URL } from \"../services/api\";\n\n// 1. Define interface for the review session data\n\n// 2. Define interface for the context value\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 3. Provide a default value matching the type for createContext\nconst defaultContextValue = {\n  pendingReviews: [],\n  pendingCount: 0,\n  completeReview: () => {} // Default function does nothing\n};\nconst ReviewSessionContext = /*#__PURE__*/createContext(defaultContextValue);\n\n// 4. Type the children prop\n\nexport const PatientProvider = ({\n  children\n}) => {\n  _s();\n  const [pendingReviews, setPendingReviews] = useState([]);\n  const [pendingCount, setPendingCount] = useState(0);\n  useEffect(() => {\n    const fetchPendingReviews = async () => {\n      try {\n        // Fetch all sessions\n        const sessionsResponse = await fetch(`${API_BASE_URL}/api/allsessions`);\n        if (!sessionsResponse.ok) {\n          throw new Error('Failed to fetch sessions');\n        }\n        const allSessions = await sessionsResponse.json();\n        console.log('All Sessions:', {\n          count: allSessions.length,\n          sessions: allSessions\n        });\n\n        // Before filtering, add validation\n        const unreviewed = allSessions.filter(session => {\n          // Check if session and feedback exist before accessing reviewed property\n          return session && session.feedback && session.feedback.reviewed === false;\n        });\n\n        // Add debug logs\n        console.log('Filtering sessions:', {\n          totalSessions: allSessions.length,\n          validSessions: allSessions.filter(s => s && s.feedback).length,\n          unreviewedSessions: unreviewed.length,\n          sampleSession: allSessions[0]\n        });\n        console.log('After filtering - Unreviewed Sessions:', {\n          totalUnreviewed: unreviewed.length,\n          reviewedCount: allSessions.length - unreviewed.length,\n          percentage: `${(unreviewed.length / allSessions.length * 100).toFixed(1)}% need review`,\n          unreviewedSamples: unreviewed.slice(0, 3).map(s => ({\n            id: s.id,\n            patientId: s.patientId,\n            feedback: s.feedback\n          }))\n        });\n        // Fetch all patients to get their names\n        const patientsResponse = await fetch(`${API_BASE_URL}/api/patients`);\n        if (!patientsResponse.ok) {\n          throw new Error('Failed to fetch patients');\n        }\n        const patients = await patientsResponse.json();\n\n        // Create review sessions array\n        const reviewSessions = unreviewed.map(session => {\n          var _session$feedback, _session$exerciseCust, _session$metrics;\n          const patient = patients.find(p => p.id === session.patientId);\n          return {\n            id: session.id,\n            name: patient ? `${patient.personalInfo.firstName} ${patient.personalInfo.lastName}` : 'Unknown Patient',\n            sessionDate: new Date(((_session$feedback = session.feedback) === null || _session$feedback === void 0 ? void 0 : _session$feedback.reviewDate) || session.duration).toLocaleDateString(),\n            exercise: ((_session$exerciseCust = session.exerciseCustomization) === null || _session$exerciseCust === void 0 ? void 0 : _session$exerciseCust.exerciseId) || 'Unknown Exercise',\n            duration: `${Math.round(session.duration / 60)} min`,\n            performance: ((_session$metrics = session.metrics) === null || _session$metrics === void 0 ? void 0 : _session$metrics.score) || 0\n          };\n        });\n        setPendingReviews(reviewSessions);\n        setPendingCount(reviewSessions.length);\n      } catch (error) {\n        console.error('Error fetching pending reviews:', error);\n        // Handle error appropriately - maybe set an error state\n      }\n    };\n    fetchPendingReviews();\n  }, []); // Empty dependency array means this runs once when component mounts\n\n  const completeReview = async sessionId => {\n    try {\n      // Update session in backend (you'll need to add this endpoint)\n      const response = await fetch(`${API_BASE_URL}/api/sessions/${sessionId}/review`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          reviewed: true,\n          reviewDate: new Date().toISOString()\n        })\n      });\n      if (!response.ok) {\n        throw new Error('Failed to update session review status');\n      }\n\n      // Update local state\n      setPendingReviews(prev => prev.filter(p => p.id !== sessionId));\n      setPendingCount(prev => Math.max(0, prev - 1));\n    } catch (error) {\n      console.error('Error completing review:', error);\n      // Handle error appropriately\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(ReviewSessionContext.Provider, {\n    value: {\n      pendingReviews,\n      pendingCount,\n      completeReview\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 136,\n    columnNumber: 5\n  }, this);\n};\n\n// 7. Type the return value of the hook\n_s(PatientProvider, \"aCUpfpTlzt5nCYcNGQ+Z90CRzAs=\");\n_c = PatientProvider;\nexport const usePatients = () => {\n  _s2();\n  const context = useContext(ReviewSessionContext);\n  if (context === undefined) {\n    // Provide a more helpful error message if used outside the provider\n    throw new Error('usePatients must be used within a PatientProvider');\n  }\n  return context;\n};\n_s2(usePatients, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"PatientProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","API_BASE_URL","jsxDEV","_jsxDEV","defaultContextValue","pendingReviews","pendingCount","completeReview","ReviewSessionContext","PatientProvider","children","_s","setPendingReviews","setPendingCount","fetchPendingReviews","sessionsResponse","fetch","ok","Error","allSessions","json","console","log","count","length","sessions","unreviewed","filter","session","feedback","reviewed","totalSessions","validSessions","s","unreviewedSessions","sampleSession","totalUnreviewed","reviewedCount","percentage","toFixed","unreviewedSamples","slice","map","id","patientId","patientsResponse","patients","reviewSessions","_session$feedback","_session$exerciseCust","_session$metrics","patient","find","p","name","personalInfo","firstName","lastName","sessionDate","Date","reviewDate","duration","toLocaleDateString","exercise","exerciseCustomization","exerciseId","Math","round","performance","metrics","score","error","sessionId","response","method","headers","body","JSON","stringify","toISOString","prev","max","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","usePatients","_s2","context","undefined","$RefreshReg$"],"sources":["/home/shambhavi/Documents/4-2/tpe/app/tpe-doctor/doctor/frontend/src/context/ReviewSessionContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from \"react\";\nimport { API_BASE_URL } from \"../services/api\";\n\n// 1. Define interface for the review session data\ninterface PatientReviewSession {\n  id: string;\n  name: string;\n  sessionDate: string;\n  exercise: string;\n  duration: string;\n  performance: number;\n}\n\n// 2. Define interface for the context value\ninterface ReviewSessionContextType {\n  pendingReviews: PatientReviewSession[];\n  pendingCount: number;\n  completeReview: (patientId: string) => void; // Typed the parameter\n}\n\n// 3. Provide a default value matching the type for createContext\nconst defaultContextValue: ReviewSessionContextType = {\n  pendingReviews: [],\n  pendingCount: 0,\n  completeReview: () => {}, // Default function does nothing\n};\n\nconst ReviewSessionContext = createContext<ReviewSessionContextType>(defaultContextValue);\n\n// 4. Type the children prop\ninterface PatientProviderProps {\n  children: ReactNode;\n}\n\nexport const PatientProvider: React.FC<PatientProviderProps> = ({ children }) => {\n  const [pendingReviews, setPendingReviews] = useState<PatientReviewSession[]>([]);\n  const [pendingCount, setPendingCount] = useState<number>(0);\n\n  useEffect(() => {\n    const fetchPendingReviews = async () => {\n      try {\n        // Fetch all sessions\n        const sessionsResponse = await fetch(`${API_BASE_URL}/api/allsessions`);\n        if (!sessionsResponse.ok) {\n          throw new Error('Failed to fetch sessions');\n        }\n        const allSessions = await sessionsResponse.json();\n        console.log('All Sessions:', {\n          count: allSessions.length,\n          sessions: allSessions,\n        });\n\n        // Before filtering, add validation\n        const unreviewed = allSessions.filter((session: any) => {\n          // Check if session and feedback exist before accessing reviewed property\n          return session && session.feedback && session.feedback.reviewed === false;\n        });\n\n        // Add debug logs\n        console.log('Filtering sessions:', {\n          totalSessions: allSessions.length,\n          validSessions: allSessions.filter(s => s && s.feedback).length,\n          unreviewedSessions: unreviewed.length,\n          sampleSession: allSessions[0],\n        });\n\n        console.log('After filtering - Unreviewed Sessions:', {\n          totalUnreviewed: unreviewed.length,\n          reviewedCount: allSessions.length - unreviewed.length,\n          percentage: `${((unreviewed.length / allSessions.length) * 100).toFixed(1)}% need review`,\n          unreviewedSamples: unreviewed.slice(0, 3).map(s => ({\n            id: s.id,\n            patientId: s.patientId,\n            feedback: s.feedback\n          }))\n        });\n        // Fetch all patients to get their names\n        const patientsResponse = await fetch(`${API_BASE_URL}/api/patients`);\n        if (!patientsResponse.ok) {\n          throw new Error('Failed to fetch patients');\n        }\n        const patients = await patientsResponse.json();\n\n        // Create review sessions array\n        const reviewSessions: PatientReviewSession[] = unreviewed.map((session: any) => {\n          const patient = patients.find((p: any) => p.id === session.patientId);\n          return {\n            id: session.id,\n            name: patient ? `${patient.personalInfo.firstName} ${patient.personalInfo.lastName}` : 'Unknown Patient',\n            sessionDate: new Date(session.feedback?.reviewDate || session.duration).toLocaleDateString(),\n            exercise: session.exerciseCustomization?.exerciseId || 'Unknown Exercise',\n            duration: `${Math.round(session.duration / 60)} min`,\n            performance: session.metrics?.score || 0\n          };\n        });\n\n        setPendingReviews(reviewSessions);\n        setPendingCount(reviewSessions.length);\n      } catch (error) {\n        console.error('Error fetching pending reviews:', error);\n        // Handle error appropriately - maybe set an error state\n      }\n    };\n\n    fetchPendingReviews();\n  }, []); // Empty dependency array means this runs once when component mounts\n\n  const completeReview = async (sessionId: string) => {\n    try {\n      // Update session in backend (you'll need to add this endpoint)\n      const response = await fetch(`${API_BASE_URL}/api/sessions/${sessionId}/review`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          reviewed: true,\n          reviewDate: new Date().toISOString(),\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update session review status');\n      }\n\n      // Update local state\n      setPendingReviews((prev) => prev.filter((p) => p.id !== sessionId));\n      setPendingCount((prev) => Math.max(0, prev - 1));\n    } catch (error) {\n      console.error('Error completing review:', error);\n      // Handle error appropriately\n    }\n  };\n\n  return (\n    <ReviewSessionContext.Provider\n      value={{ pendingReviews, pendingCount, completeReview }}\n    >\n      {children}\n    </ReviewSessionContext.Provider>\n  );\n};\n\n// 7. Type the return value of the hook\nexport const usePatients = (): ReviewSessionContextType => {\n  const context = useContext(ReviewSessionContext);\n  if (context === undefined) {\n    // Provide a more helpful error message if used outside the provider\n    throw new Error('usePatients must be used within a PatientProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}