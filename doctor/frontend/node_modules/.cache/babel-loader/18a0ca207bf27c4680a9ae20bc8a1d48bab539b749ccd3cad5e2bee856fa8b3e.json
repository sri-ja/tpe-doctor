{"ast":null,"code":"var _jsxFileName = \"/home/shambhavi/Documents/4-2/tpe/app/tpe-doctor/doctor/frontend/src/context/ReviewSessionContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from \"react\";\nimport { API_BASE_URL } from \"../services/api\";\n\n// 1. Define interface for the review session data\n\n// 2. Define interface for the context value\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 3. Provide a default value matching the type for createContext\nconst defaultContextValue = {\n  pendingReviews: [],\n  pendingCount: 0,\n  completeReview: () => {} // Default function does nothing\n};\nconst ReviewSessionContext = /*#__PURE__*/createContext(defaultContextValue);\n\n// 4. Type the children prop\n\nexport const PatientProvider = ({\n  children\n}) => {\n  _s();\n  const [pendingReviews, setPendingReviews] = useState([]);\n  const [pendingCount, setPendingCount] = useState(0);\n  useEffect(() => {\n    const fetchPendingReviews = async () => {\n      try {\n        // Fetch all sessions\n        const sessionsResponse = await fetch(`${API_BASE_URL}/api/allsessions`);\n        if (!sessionsResponse.ok) {\n          throw new Error('Failed to fetch sessions');\n        }\n        const allSessions = await sessionsResponse.json();\n\n        // Filter sessions that need review\n        const unreviewed = allSessions.filter(session => !session.feedback.reviewed);\n\n        // Fetch all patients to get their names\n        const patientsResponse = await fetch(`${API_BASE_URL}/api/patients`);\n        if (!patientsResponse.ok) {\n          throw new Error('Failed to fetch patients');\n        }\n        const patients = await patientsResponse.json();\n\n        // Create review sessions array\n        const reviewSessions = unreviewed.map(session => {\n          var _session$feedback, _session$exerciseCust, _session$metrics;\n          const patient = patients.find(p => p.id === session.patientId);\n          return {\n            id: session.id,\n            name: patient ? `${patient.personalInfo.firstName} ${patient.personalInfo.lastName}` : 'Unknown Patient',\n            sessionDate: new Date(((_session$feedback = session.feedback) === null || _session$feedback === void 0 ? void 0 : _session$feedback.reviewDate) || session.duration).toLocaleDateString(),\n            exercise: ((_session$exerciseCust = session.exerciseCustomization) === null || _session$exerciseCust === void 0 ? void 0 : _session$exerciseCust.exerciseId) || 'Unknown Exercise',\n            duration: `${Math.round(session.duration / 60)} min`,\n            performance: ((_session$metrics = session.metrics) === null || _session$metrics === void 0 ? void 0 : _session$metrics.score) || 0\n          };\n        });\n        setPendingReviews(reviewSessions);\n        setPendingCount(reviewSessions.length);\n      } catch (error) {\n        console.error('Error fetching pending reviews:', error);\n        // Handle error appropriately - maybe set an error state\n      }\n    };\n    fetchPendingReviews();\n  }, []); // Empty dependency array means this runs once when component mounts\n\n  const completeReview = async sessionId => {\n    try {\n      // Update session in backend (you'll need to add this endpoint)\n      const response = await fetch(`${API_BASE_URL}/api/sessions/${sessionId}/review`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          reviewed: true,\n          reviewDate: new Date().toISOString()\n        })\n      });\n      if (!response.ok) {\n        throw new Error('Failed to update session review status');\n      }\n\n      // Update local state\n      setPendingReviews(prev => prev.filter(p => p.id !== sessionId));\n      setPendingCount(prev => Math.max(0, prev - 1));\n    } catch (error) {\n      console.error('Error completing review:', error);\n      // Handle error appropriately\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(ReviewSessionContext.Provider, {\n    value: {\n      pendingReviews,\n      pendingCount,\n      completeReview\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 111,\n    columnNumber: 5\n  }, this);\n};\n\n// 7. Type the return value of the hook\n_s(PatientProvider, \"aCUpfpTlzt5nCYcNGQ+Z90CRzAs=\");\n_c = PatientProvider;\nexport const usePatients = () => {\n  _s2();\n  const context = useContext(ReviewSessionContext);\n  if (context === undefined) {\n    // Provide a more helpful error message if used outside the provider\n    throw new Error('usePatients must be used within a PatientProvider');\n  }\n  return context;\n};\n_s2(usePatients, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"PatientProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","API_BASE_URL","jsxDEV","_jsxDEV","defaultContextValue","pendingReviews","pendingCount","completeReview","ReviewSessionContext","PatientProvider","children","_s","setPendingReviews","setPendingCount","fetchPendingReviews","sessionsResponse","fetch","ok","Error","allSessions","json","unreviewed","filter","session","feedback","reviewed","patientsResponse","patients","reviewSessions","map","_session$feedback","_session$exerciseCust","_session$metrics","patient","find","p","id","patientId","name","personalInfo","firstName","lastName","sessionDate","Date","reviewDate","duration","toLocaleDateString","exercise","exerciseCustomization","exerciseId","Math","round","performance","metrics","score","length","error","console","sessionId","response","method","headers","body","JSON","stringify","toISOString","prev","max","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","usePatients","_s2","context","undefined","$RefreshReg$"],"sources":["/home/shambhavi/Documents/4-2/tpe/app/tpe-doctor/doctor/frontend/src/context/ReviewSessionContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from \"react\";\nimport { API_BASE_URL } from \"../services/api\";\n\n// 1. Define interface for the review session data\ninterface PatientReviewSession {\n  id: string;\n  name: string;\n  sessionDate: string;\n  exercise: string;\n  duration: string;\n  performance: number;\n}\n\n// 2. Define interface for the context value\ninterface ReviewSessionContextType {\n  pendingReviews: PatientReviewSession[];\n  pendingCount: number;\n  completeReview: (patientId: string) => void; // Typed the parameter\n}\n\n// 3. Provide a default value matching the type for createContext\nconst defaultContextValue: ReviewSessionContextType = {\n  pendingReviews: [],\n  pendingCount: 0,\n  completeReview: () => {}, // Default function does nothing\n};\n\nconst ReviewSessionContext = createContext<ReviewSessionContextType>(defaultContextValue);\n\n// 4. Type the children prop\ninterface PatientProviderProps {\n  children: ReactNode;\n}\n\nexport const PatientProvider: React.FC<PatientProviderProps> = ({ children }) => {\n  const [pendingReviews, setPendingReviews] = useState<PatientReviewSession[]>([]);\n  const [pendingCount, setPendingCount] = useState<number>(0);\n\n  useEffect(() => {\n    const fetchPendingReviews = async () => {\n      try {\n        // Fetch all sessions\n        const sessionsResponse = await fetch(`${API_BASE_URL}/api/allsessions`);\n        if (!sessionsResponse.ok) {\n          throw new Error('Failed to fetch sessions');\n        }\n        const allSessions = await sessionsResponse.json();\n\n        // Filter sessions that need review\n        const unreviewed = allSessions.filter((session: any) => !session.feedback.reviewed);\n\n        // Fetch all patients to get their names\n        const patientsResponse = await fetch(`${API_BASE_URL}/api/patients`);\n        if (!patientsResponse.ok) {\n          throw new Error('Failed to fetch patients');\n        }\n        const patients = await patientsResponse.json();\n\n        // Create review sessions array\n        const reviewSessions: PatientReviewSession[] = unreviewed.map((session: any) => {\n          const patient = patients.find((p: any) => p.id === session.patientId);\n          return {\n            id: session.id,\n            name: patient ? `${patient.personalInfo.firstName} ${patient.personalInfo.lastName}` : 'Unknown Patient',\n            sessionDate: new Date(session.feedback?.reviewDate || session.duration).toLocaleDateString(),\n            exercise: session.exerciseCustomization?.exerciseId || 'Unknown Exercise',\n            duration: `${Math.round(session.duration / 60)} min`,\n            performance: session.metrics?.score || 0\n          };\n        });\n\n        setPendingReviews(reviewSessions);\n        setPendingCount(reviewSessions.length);\n      } catch (error) {\n        console.error('Error fetching pending reviews:', error);\n        // Handle error appropriately - maybe set an error state\n      }\n    };\n\n    fetchPendingReviews();\n  }, []); // Empty dependency array means this runs once when component mounts\n\n  const completeReview = async (sessionId: string) => {\n    try {\n      // Update session in backend (you'll need to add this endpoint)\n      const response = await fetch(`${API_BASE_URL}/api/sessions/${sessionId}/review`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          reviewed: true,\n          reviewDate: new Date().toISOString(),\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update session review status');\n      }\n\n      // Update local state\n      setPendingReviews((prev) => prev.filter((p) => p.id !== sessionId));\n      setPendingCount((prev) => Math.max(0, prev - 1));\n    } catch (error) {\n      console.error('Error completing review:', error);\n      // Handle error appropriately\n    }\n  };\n\n  return (\n    <ReviewSessionContext.Provider\n      value={{ pendingReviews, pendingCount, completeReview }}\n    >\n      {children}\n    </ReviewSessionContext.Provider>\n  );\n};\n\n// 7. Type the return value of the hook\nexport const usePatients = (): ReviewSessionContextType => {\n  const context = useContext(ReviewSessionContext);\n  if (context === undefined) {\n    // Provide a more helpful error message if used outside the provider\n    throw new Error('usePatients must be used within a PatientProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}